public final class shark/DiffingHeapGrowthDetector {
	public fun <init> ()V
	public fun <init> (Lshark/ReferenceReader$Factory;Lshark/GcRootProvider;)V
	public synthetic fun <init> (Lshark/ReferenceReader$Factory;Lshark/GcRootProvider;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun detectHeapGrowth (Lshark/DiffingHeapGrowthDetector$HeapDumpAfterLoopingScenario;Lshark/InputHeapTraversal;)Lshark/HeapTraversal;
	public static synthetic fun detectHeapGrowth$default (Lshark/DiffingHeapGrowthDetector;Lshark/DiffingHeapGrowthDetector$HeapDumpAfterLoopingScenario;Lshark/InputHeapTraversal;ILjava/lang/Object;)Lshark/HeapTraversal;
}

public final class shark/DiffingHeapGrowthDetector$HeapDumpAfterLoopingScenario {
	public fun <init> (Lshark/CloseableHeapGraph;I)V
	public final fun component1 ()Lshark/CloseableHeapGraph;
	public final fun component2 ()I
	public final fun copy (Lshark/CloseableHeapGraph;I)Lshark/DiffingHeapGrowthDetector$HeapDumpAfterLoopingScenario;
	public static synthetic fun copy$default (Lshark/DiffingHeapGrowthDetector$HeapDumpAfterLoopingScenario;Lshark/CloseableHeapGraph;IILjava/lang/Object;)Lshark/DiffingHeapGrowthDetector$HeapDumpAfterLoopingScenario;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getHeapGraph ()Lshark/CloseableHeapGraph;
	public final fun getScenarioLoopCount ()I
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public final class shark/HeapGrowthAssertionsKt {
	public static final fun assertNoHeapGrowth (Lkotlin/sequences/Sequence;)V
	public static final fun assertNoHeapGrowth (Lshark/ScenarioLoopHeapDumper;Lkotlin/jvm/functions/Function0;)V
}

public abstract interface class shark/HeapTraversal : shark/InputHeapTraversal {
	public static final field Companion Lshark/HeapTraversal$Companion;
	public abstract fun getGrowing ()Z
	public abstract fun getShortestPathTree ()Lshark/ShortestPathNode;
}

public final class shark/HeapTraversal$Companion {
	public final fun getIgnoredReferences ()Ljava/util/List;
}

public final class shark/HeapTraversalWithDiff : shark/HeapTraversal {
	public fun <init> (Lshark/ShortestPathNode;Ljava/util/List;)V
	public fun getGrowing ()Z
	public final fun getGrowingNodes ()Ljava/util/List;
	public fun getShortestPathTree ()Lshark/ShortestPathNode;
	public fun toString ()Ljava/lang/String;
}

public final class shark/InitialHeapTraversal : shark/HeapTraversal {
	public fun <init> (Lshark/ShortestPathNode;)V
	public fun getGrowing ()Z
	public fun getShortestPathTree ()Lshark/ShortestPathNode;
}

public abstract interface class shark/InputHeapTraversal {
}

public final class shark/LoopingHeapGrowthDetector {
	public fun <init> (Lshark/DiffingHeapGrowthDetector;)V
	public final fun repeatDiffsWhileGrowing (Lkotlin/sequences/Sequence;)Lshark/HeapTraversalWithDiff;
}

public final class shark/NoHeapTraversalYet : shark/InputHeapTraversal {
	public static final field INSTANCE Lshark/NoHeapTraversalYet;
}

public final class shark/ScenarioLoopHeapDumper {
	public fun <init> (ILshark/HeapGraphProvider;I)V
	public synthetic fun <init> (ILshark/HeapGraphProvider;IILkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun sequenceOfHeapDumps (Lkotlin/jvm/functions/Function0;)Lkotlin/sequences/Sequence;
}

public final class shark/ShortestPathNode {
	public fun <init> (Ljava/lang/String;Lshark/ShortestPathNode;Z)V
	public final fun getChildren ()Ljava/util/List;
	public final fun getChildrenObjectCount ()I
	public final fun getChildrenObjectCountIncrease ()I
	public final fun getNodeAndEdgeName ()Ljava/lang/String;
	public final fun getParent ()Lshark/ShortestPathNode;
	public final fun getSelfObjectCount ()I
	public final fun getSelfObjectCountIncrease ()I
	public final fun pathFromRootAsString ()Ljava/lang/String;
	public fun toString ()Ljava/lang/String;
}

